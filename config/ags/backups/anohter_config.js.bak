import Gdk from "gi://Gdk";
import Gtk from "gi://Gtk";
import brightness from "./brightness.js";
//const hyprland = await Service.import("hyprland");
const notifications = await Service.import("notifications");
const mpris = await Service.import("mpris");
const audio = await Service.import("audio");
//const battery = await Service.import("battery");
//const systemtray = await Service.import("systemtray");
//const network = await Service.import("network");

Utils.monitorFile(
    // directory that contains the scss files
    `${App.configDir}`,

    // reload function
    function() {
        // main scss file
        //const css = `${App.configDir}/control_center/style.css`;
        const css = `/home/sawhill/dots/config/ags/control_center/style.css`;

        App.resetCss();
        App.applyCss(css);
    },
);



const ControlCenterHeaderBox = Widget.Box({
    class_name: "ControlCenterHeaderBox",
    vertical: false,
    homogeneous: true,
    children: [
        Widget.Button({
            class_name: "ControlCenterHeaderButtons",
            label: "",
        }),
        Widget.Button({
            class_name: "ControlCenterHeaderButtons",
            label: "",
        }),
        Widget.Button({
            class_name: "ControlCenterHeaderButtons",
            label: ""

        }),
        Widget.Button({
            class_name: "ControlCenterHeaderButtons",
            label: "",
        }),
        Widget.Button({
            class_name: "ControlCenterHeaderButtons",
            label: "󱎴",
        }),
    ],
});


function Volume() {
    const icons = {
        101: "overamplified",
        67: "high",
        34: "medium",
        1: "low",
        0: "muted",
    };

    function getIcon() {
        const icon = audio.speaker.is_muted ? 0 : [101, 67, 34, 1, 0].find(
            threshold => threshold <= audio.speaker.volume * 100)

        return `audio-volume-${icons[icon]}-symbolic`
    }

    const icon = Widget.Icon({
        class_name: "VolumeIcon",
        icon: Utils.watch(getIcon(), audio.speaker, getIcon),
        size: 20,
    });

    const slider = Widget.Slider({
        class_name: "VolumeSlider",
        hexpand: true,
        draw_value: false,
        max: 1.5,
        min: 0,
        step: 0.01,
        on_change: ({ value }) => audio.speaker.volume = value,
        setup: self => self.hook(audio.speaker, () => {
            self.value = audio.speaker.volume || 0;
            self.tooltip_text = `${Math.floor(audio.speaker.volume * 100)}`;
        }),
    });

    return Widget.Box({
        class_name: "VolumeBox",
        css: "min-width: 180px",
        children: [icon, slider],
    });
}


function Brightness() {
    const label = Widget.Label({
        class_name: "BrightnessLabel",
        label: "󰃝",
    });

    const slider = Widget.Slider({
        class_name: "BrightnessSlider",
        hexpand: true,
        draw_value: false,
        max: 1,
        min: 0.01,
        step: 0.015,
        on_change: self => brightness.screen_value = self.value,
        setup: self => self.hook(brightness, () => {
            self.value = brightness.screen_value || 0;
            self.tooltip_text = `${Math.floor(brightness.screen_value * 100)}`;
        }),
    });

    return Widget.Box({
        class_name: "BrightnessBox",
        css: "min-width: 180px",
        children: [label, slider],
    });

}


const players = mpris.bind("players");
/** @param {import('types/service/mpris').MprisPlayer} player */
function Player(player) {

    const FALLBACK_ICON = "audio-x-generic-symbolic";
    const PLAY_ICON = "media-playback-start-symbolic";
    const PAUSE_ICON = "media-playback-pause-symbolic";
    const PREV_ICON = "media-skip-backward-symbolic";
    const NEXT_ICON = "media-skip-forward-symbolic";

    /** @param {number} length */
    function lengthStr(length) {
        const min = Math.floor(length / 60);
        const sec = Math.floor(length % 60);
        const sec0 = sec < 10 ? "0" : "";
        return `${min}:${sec0}${sec}`;
    }

    const img = Widget.Box({
        class_name: "MediaPlayerImage",
        vpack: "start",
        css: player.bind("cover_path").transform(p => {
            if (!p) {
                return `
                min-width: 0px;
                min-height: 0px;
                border: none;
                margin: 0px;
                padding: 0px;
                `;
            } else {
                return ` 
                background-image: url('${p}');
                min-width: 100px;
                min-height: 100px;
                `;
            }
        },
        ),
    });

    const title = Widget.Label({
        class_name: "MediaPlayerTitle",
        wrap: true,
        hpack: "start",
        maxWidthChars: 30,
        truncate: "end",
        label: player.bind("track_title"),
    });

    const artist = Widget.Label({
        class_name: "MediaPlayerArtist",
        wrap: true,
        hpack: "start",
        maxWidthChars: 30,
        lines: 2,
        truncate: "end",
        label: player.bind("track_artists").transform(a => a.join(", ")),
    });

    const positionSlider = Widget.Slider({
        class_name: "MediaPlayerSlider",
        draw_value: false,
        on_change: ({ value }) => player.position = value * player.length,
        visible: player.bind("length").as(l => l > 0),
        setup: self => {
            function update() {
                const value = player.position / player.length
                self.value = value > 0 ? value : 0
            }
            self.hook(player, update)
            self.hook(player, update, "position")
            self.poll(1000, update)
        },
    });

    const TimeElapsedLabel = Widget.Label({
        class_name: "MediaPlayerSliderLabelTimeElapsed",
        hpack: "start",
        setup: self => {
            const update = (_, time) => {
                self.label = lengthStr(time || player.position);
                self.visible = player.length > 0;
            };

            self.hook(player, update, "position");
            self.poll(1000, update);
        },
    });

    const TotalTimeLabel = Widget.Label({
        class_name: "MediaPlayerSliderLabelTotalTime",
        hpack: "end",
        visible: player.bind("length").transform(l => l > 0),
        label: player.bind("length").transform(lengthStr),
    });

    const icon = Widget.Icon({
        class_name: "MediaPlayerIcon",
        hexpand: true,
        hpack: "end",
        vpack: "start",
        tooltip_text: player.identity || "",
        icon: player.bind("entry").transform(entry => {
            const name = `${entry}-symbolic`;
            return Utils.lookUpIcon(name) ? name : FALLBACK_ICON;
        }),
    });

    const playPause = Widget.Button({
        class_name: "MediaPlayerPlayPauseButton",
        on_clicked: () => player.playPause(),
        visible: player.bind("can_play"),
        child: Widget.Icon({
            icon: player.bind("play_back_status").transform(s => {
                switch (s) {
                    case "Playing": return PAUSE_ICON;
                    case "Paused":
                    case "Stopped": return PLAY_ICON;
                }
            }),
        }),
    });

    const prev = Widget.Button({
        className: "MediaPlayerPrevButton",
        on_clicked: () => player.previous(),
        visible: player.bind("can_go_prev"),
        child: Widget.Icon(PREV_ICON),
    });

    const next = Widget.Button({
        className: "MediaPlayerNextButton",
        on_clicked: () => player.next(),
        visible: player.bind("can_go_next"),
        child: Widget.Icon(NEXT_ICON),
    });

    return Widget.Box(
        {
            class_name: "MediaPlayer",
            vexpand: false,
        },
        img,
        Widget.Box(
            {
                vertical: true,
                hexpand: true,
            },
            Widget.Box([
                title,
                icon,
            ]),
            artist,
            positionSlider,
            Widget.Box({ vexpand: true }),
            Widget.CenterBox({
                start_widget: TimeElapsedLabel,
                center_widget: Widget.Box([
                    prev,
                    playPause,
                    next,
                ]),
                end_widget: TotalTimeLabel,
            }),

        ),
    );
}

const Media = Widget.Box({
    class_name: "MediaBox",
    vertical: true,
    visible: players.as(p => p.length > 0),
    children: players.as(p => p.map(Player)),
}).hook(mpris, (self) => {
    Media.visible = mpris.players.length > 0;
    if (mpris.players.length == 0) {
        self.hide();
    }
});

/** @param {import('resource:///com/github/Aylur/ags/service/notifications.js').Notification} n */
function Notification(n) {

    /** @param {import('resource:///com/github/Aylur/ags/service/notifications.js').Notification} n */
    function NotificationIcon({ app_entry, app_icon, image }) {
        if (image) {
            return Widget.Box({
                className: "NotificationImageBox",
                css: `background-image: url("${image}");
                 background-size: contain;
                 background-repeat: no-repeat;
                 background-position: center;`,
            });
        }

        let icon = "dialog-information-symbolic";
        if (Utils.lookUpIcon(app_icon))
            icon = app_icon;

        if (app_entry && Utils.lookUpIcon(app_entry))
            icon = app_entry;

        return Widget.Box({
            class_name: "NotificationIconBox",
            child: Widget.Icon(
                {
                    icon: icon,
                    size: 30,
                }
            ),
            homogeneous: true,
        });
    }

    const icon = Widget.Box({
        vpack: "start",
        class_name: "NotificationIconAndImageContainerBox",
        child: NotificationIcon(n),
    });

    const title = Widget.Label({
        class_name: "NotificationTitleLabel",
        xalign: 0,
        justification: "left",
        hexpand: true,
        max_width_chars: 24,
        truncate: "end",
        wrap: true,
        label: n.summary,
        use_markup: true,
    });

    const body = Widget.Label({
        class_name: "NotificationBodyLabel",
        hexpand: true,
        use_markup: true,
        xalign: 0,
        justification: "left",
        label: n.body,
        wrap: true,
    });

    const actions = Widget.Box({
        class_name: "NotificationActionsBox",
        children: n.actions.map(({ id, label }) => Widget.Button({
            class_name: "NotificationActionButton",
            on_clicked: () => {
                n.invoke(id);
                n.dismiss();
            },
            hexpand: true,
            child: Widget.Label(label),
        })),
    });

    return Widget.EventBox(
        {
            attribute: { id: n.id },
            on_primary_click: n.close,
        },
        Widget.Box(
            {
                class_name: `NotificationBox ${n.urgency}`,
                vertical: true,
            },
            Widget.Box({
                class_name: "NotificationIconAndTitleBox",
                spacing: 10,
                children: [
                    icon,
                    Widget.Box(
                        {
                            vertical: true,
                            valign: Gtk.Align.END,
                            class_name: "NotificationTitleBox",
                        },
                        title,
                    ),]
            },
            ),
            body,
            actions,
        ),
    );
}

export function NotificationList(monitor = 0) {
    //Notificaion list based on speicfied apps
    //
    const groupedList = notifications.notifications.reduce((result, currentNoti) => {
        const group = currentNoti.app_name;
        if (!result[group]) {
            result[group] = [];
        }
        result[group].push(currentNoti);
        return result;
    }, {});
    //console.log(grouped);
    //
    const liste = Widget.Box({
        vertical: true,
        children: Object.keys(groupedList).map(group => {
            return Widget.Box({
                class_name: "NotificationGroup",
                vertical: true,
                valign: Gtk.Align.FILL,
                children: [
                    Widget.Box({
                        class_name: "NotificationGroupHeaderBox",
                        vertical: false,
                        spacing: 10,
                        hpack: "fill",
                        children: [
                            Widget.Label({
                                class_name: "NotificationGroupLabel",
                                label: group,
                            }),
                            Widget.Box({
                                hexpand: true,
                            }),
                            Widget.Button({
                                class_name: "NotificationGroupExpandButton",
                                label: "󰘖",
                                onClicked: (self) => {
                                    self.label = "󰘕";
                                    //toggle the reveal child
                                    self.parent.parent.children[1].reveal_child = !self.parent.parent.children[1].reveal_child;
                                },
                            }),
                            Widget.Button({
                                class_name: "NotificationGroupClearButton",
                                label: "",
                            }),
                        ],
                    }),
                    Widget.Revealer({
                        class_name: "NotificationGroupRevealer",
                        revealChild: false,
                        transitionDuration: 500,
                        transition: "slide_down",
                        child: Widget.Box({
                            vertical: true,
                            children: groupedList[group].map(Notification),
                        }),
                        setup: self => () => {
                            // self.reveal_child = false;
                        },
                    }),
                ],
            });
        }),
    });


    const list = Widget.Box({
        vertical: true,
        children: notifications.notifications.map(Notification),
    });

    function onNotified(_, /** @type {number} */ id) {
        const n = notifications.getNotification(id);
        if (n)
            list.children = [Notification(n), ...list.children];
    }

    function onClosed(_, /** @type {number} */ id) {
        list.children.find(n => n.attribute.id === id)?.destroy();
    }

    list.hook(notifications, onNotified, "notified")
        .hook(notifications, onClosed, "closed");

    return Widget.Scrollable({
        class_name: "NotificationContainerScrollable",
        vscroll: "automatic",
        hscroll: "never",
        vexpand: true,
        child: liste,
        /** this is a simple one liner that could be used instead of
            hooking into the 'notified' and 'dismissed' signals.
            but its not very optimized becuase it will recreate
            the whole list everytime a notification is added or dismissed */
        // children: notifications.bind('popups')
        //     .as(popups => popups.map(Notification))
    });
}

const NotificaitonHeader = Widget.Box({
    class_name: "NotificationHeaderBox",
    vertical: false,
    hpack: "fill",
    children: [
        Widget.Label({
            class_name: "NotificationHeaderLabel",
            label: "Notifications",
        }),
        Widget.Box({
            hexpand: true,
        }),
        Widget.Button({
            class_name: "NotificationHeaderClearButton",
            label: "",
            onClicked: notifications.clear,
        }),
    ]
});

const NotificationMainBox = Widget.Box({
    class_name: "NotificationMainBox",
    vertical: true,
    vexpand: true,
    spacing: 10,
    children: [
        NotificaitonHeader,
        NotificationList(),
    ],
});

const Dnd = Widget.Box({
    class_name: "DndBox",
    vertical: false,
    hpack: "fill",
    children: [
        Widget.Label({
            class_name: "DndLabel",
            label: "Do not disturb",
        }),
        Widget.Box({
            hexpand: true,
        }),
        Widget.Switch({
            class_name: "DndSwitch",
            onActivate: ({ active }) => notifications.dnd = active,
            setup: self => self.active = notifications.dnd,
        }),
    ]
});

function ControlCenter(monitor = 0) {
    return Widget.Window({
        monitor,
        name: `ControlCenter-${monitor}`, // name has to be unique
        widthRequest: 450,
        class_name: "ControlCenter",
        margins: [10, 10, 10, 0],
        anchor: ["top", "bottom", "right"],
        exclusivity: "normal",
        child: Widget.Box({
            class_name: "ControlCenterMainBox",
            vertical: true,
            spacing: 10,
            children: [
                ControlCenterHeaderBox,
                Brightness(),
                Volume(),
                Media,
                NotificationMainBox,
                Dnd,
            ],
        }),
    });
}

App.config({
    style: "./style.css",
    windows: [
        ControlCenter(0),
        // you can call it, for each monitor
        // Bar(0),
        // Bar(1)
    ],
});

export { }

